options
{
    // BUILD_TOKEN_MANAGER = false;
    JDK_VERSION = "1.8";
    STATIC = false;
    SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
    // USER_CHAR_STREAM = true;
}

PARSER_BEGIN(Parser)
package owl.lang;

import java.util.ArrayList;
import java.util.List;

public class Parser {
}

PARSER_END(Parser)

SKIP:
{
    " "
  | "\r"
  | "\n"
  | "\t"
  | < "#" (~["\n"])* >
}

TOKEN:
{
    <ELIF: "elif">
|   <ELSE: "else">
|   <FN: "fn">
|   <IF: "if">
|   <IS: "is">
|   <NEW: "new">
|   <DOT: ".">
|   <COMMA: ",">
|   <COLON: ":">
|   <SEMICOLON: ";">
|   <LPAREN: "(">
|   <RPAREN: ")">
|   <LCURLY: "{">
|   <RCURLY: "}">
|   <LBRACKET: "[">
|   <RBRACKET: "]">
|   <AT: "@">
|   <TILDE: "~">
|   <EXC: "!">
|   <ASSIGN_MUL: "*=">
|   <MUL: "*">
|   <ASSIGN_DIV: "/=">
|   <DIV: "/">
|   <ASSIGN_MOD: "%=">
|   <MOD: "%">
|   <ASSIGN_PLS: "+=">
|   <PLS: "+">
|   <ASSIGN_MNS: "-=">
|   <MNS: "-">
|   <ASSIGN_LSHIFT: "<<=">
|   <LSHIFT: "<<">
|   <ASSIGN_RSHIFT: ">>=">
|   <RSHIFT: ">>">
|   <SIGNED_RSHIFT: ">>>">
|   <ASSIGN_SIGNED_RSHIFT: ">>>=">
|   <ARROW: "=>">
|   <EQ: "==">
|   <NE: "!=">
|   <LE: "<=">
|   <LT: "<">
|   <GE: ">=">
|   <GT: ">">
|   <AND: "&&">
|   <OR: "||">
|   <ASSIGN_BIT_AND: "&=">
|   <BIT_AND: "&">
|   <ASSIGN_BIT_XOR: "^=">
|   <BIT_XOR: "^">
|   <ASSIGN_BIT_OR: "|=">
|   <BIT_OR: "|">
|   <ASSIGN: "=">
|   <OCT: "0o" (["0"-"7"])+>
|   <DEC: (["0"-"9"])+>
|   <HEX: "0x" (["0"-"9", "a"-"f", "A"-"F"])+>
|   <NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

AstModule module():
{
    AstModule m = new AstModule();
    AstFunction f;
}
{
    (
        f = function() { m.addFunction(f); }
    )*
    { return m; }
}

AstName name():
{
    Token tok;
}
{
    tok = <NAME> { return new AstName(tok.image); }
}

AstName qualifiedName():
{
    String name;
    Token tok;
}
{
    tok = <NAME> { name = tok.image; }
    (
        <DOT> tok = <NAME>
        {
            name += "." + tok.image;
        }
    )*
    { return new AstName(name); }
}

AstFunction function():
{
    AstFunction f = new AstFunction();
    AstVariable arg;
}
{
    <FN> f.name = <NAME>.image
    (
        <LPAREN>
        (
            arg = variable() { f.args.add(arg); }
            (
                "," arg = variable() { f.args.add(arg); }
            )*
        )?
        <RPAREN>
    )?
    (
        <COLON> f.returnType = type()
    )?
    f.block = block()
    { return f; }
}

AstVariable variable():
{
    AstVariable v = new AstVariable();
    Token tok;
}
{
    tok = <NAME> { v.name = tok.image; }
    (
        <COLON> v.type = type()
    )?
    { return v; }
}

AstBlock block():
{
    AstBlock b = new AstBlock();
    AstNode s;
}
{
    <LCURLY>
    (
        s = statement() { b.statements.add(s); }
    )*
    <RCURLY>
    { return b; }
}

AstNode prime():
{
    AstNode p = null;
    Token tok;
}
{
    (
        p = name()
    |   tok = <OCT>  { p = new AstConstant(tok.image); }
    |   tok = <DEC>  { p = new AstConstant(tok.image); }
    |   tok = <HEX>  { p = new AstConstant(tok.image); }
    |   <LPAREN> p = expression() <RPAREN>
    )
    { return p; }
}

AstNode call():
{
    AstNode r, arg;
    AstName n;
    AstApply apply;
}
{
    r = prime()
    (
        (
            // Member lookup.
            <DOT> n = name()
            {
                AstMember m = new AstMember();
                m.left = r;
                m.name = n;
                r = m;
            }

        |   // Regular function call with ().
            {
                apply = new AstApply();
                apply.args.add(r);
                r = apply;
            }
            <LPAREN>
            (
                arg = expression() { apply.args.add(arg); }
                (
                    <COMMA> arg = expression() { apply.args.add(arg); }
                )*
            )?
            <RPAREN>

        |   // Array index [].
            {
                apply = new AstApply();
                apply.args.add(new AstName("[]"));
                apply.args.add(r);
                r = apply;
            }
            <LBRACKET>
            (
                arg = expression() { apply.args.add(arg); }
                (
                    <COMMA> arg = expression() { apply.args.add(arg); }
                )*
            )?
            <RBRACKET>
        )
    )*
    { return r; }
}

AstNode cast():
{
    AstNode r, t;
}
{
    r = call()
    (
        <COLON> t = type()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(":"));
            apply.args.add(r);
            apply.args.add(t);
            r = apply;
        }
    )?
    { return r; }
}

AstNode unary():
{
    Token op = null;
    AstNode n;
}
{
    (op = <TILDE> | op = <PLS> | op = <MNS>)? n = cast()
    {
        if (op == null) {
            return n;
        }
        AstApply apply = new AstApply();
        apply.args.add(new AstName(op.image));
        apply.args.add(n);
        return apply;
    }
}

Token multiplicativeOp():
{
    Token tok;
}
{
    tok = <MUL> { return tok; }
|   tok = <DIV> { return tok; }
|   tok = <MOD> { return tok; }
}

AstNode multiplicative():
{
    Token op;
    AstNode l, r;
}
{
    l = unary()
    (
        op = multiplicativeOp() r = unary()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

Token additiveOp():
{
    Token tok;
}
{
    tok = <PLS> { return tok; }
|   tok = <MNS> { return tok; }
}

AstNode additive():
{
    Token op;
    AstNode l, r;
}
{
    l = multiplicative()
    (
        op = additiveOp() r = multiplicative()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

Token shiftOp():
{
    Token tok;
}
{
    tok = <LSHIFT> { return tok; }
|   tok = <RSHIFT> { return tok; }
|   tok = <SIGNED_RSHIFT> { return tok; }
}

AstNode shift():
{
    Token op;
    AstNode l, r;
}
{
    l = additive()
    (
        op = shiftOp() r = additive()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitAnd():
{
    Token op;
    AstNode l, r;
}
{
    l = shift()
    (
        op = <BIT_AND> r = shift()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitXor():
{
    Token op;
    AstNode l, r;
}
{
    l = bitAnd()
    (
        op = <BIT_XOR> r = bitAnd()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitOr():
{
    Token op;
    AstNode l, r;
}
{
    l = bitXor()
    (
        op = <BIT_OR> r = bitXor()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

Token comparisonOp():
{
    Token tok;
}
{
    tok = <LT> { return tok; }
|   tok = <LE> { return tok; }
|   tok = <GT> { return tok; }
|   tok = <GE> { return tok; }
}

AstNode comparison():
{
    Token op;
    AstNode l, r;
}
{
    l = bitOr()
    (
        op = comparisonOp() r = bitOr()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

Token equalityOp():
{
    Token tok;
}
{
    tok = <EQ> { return tok; }
|   tok = <NE> { return tok; }
|   tok = <IS> { return tok; }
}

AstNode equality():
{
    Token op;
    AstNode l, r;
}
{
    l = comparison()
    (
        op = equalityOp() r = comparison()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode logicalNot():
{
    Token op = null;
    AstNode l;
}
{
    (op = <EXC>)? l = equality()
    {
        if (op == null) {
            return l;
        } else {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            return apply;
        }
    }
}


AstNode logicalAnd():
{
    Token op;
    AstNode l, r;
}
{
    l = logicalNot()
    (
        op = <AND> r = logicalNot()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode logicalOr():
{
    Token op;
    AstNode l, r;
}
{
    l = logicalAnd()
    (
        op = <OR> r = logicalAnd()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}


Token assignmentOp():
{
    Token tok;
}
{
    tok = <ASSIGN> { return tok; }
|   tok = <ASSIGN_MUL> { return tok; }
|   tok = <ASSIGN_DIV> { return tok; }
|   tok = <ASSIGN_MOD> { return tok; }
|   tok = <ASSIGN_PLS> { return tok; }
|   tok = <ASSIGN_MNS> { return tok; }
|   tok = <ASSIGN_LSHIFT> { return tok; }
|   tok = <ASSIGN_RSHIFT> { return tok; }
|   tok = <ASSIGN_SIGNED_RSHIFT> { return tok; }
|   tok = <ASSIGN_BIT_AND> { return tok; }
|   tok = <ASSIGN_BIT_XOR> { return tok; }
|   tok = <ASSIGN_BIT_OR>  { return tok; }
}

AstNode assignment():
{
    Token op;
    AstNode l, r;
}
{
    l = logicalOr()
    (
        op = assignmentOp() r = logicalOr()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )?
    { return l; }
}

AstNode expression():
{
    AstNode n;
}
{
    n = assignment() { return n; }
}

AstNode stmtIf():
{
    AstIf stmt = new AstIf();
    AstNode c, b;
}
{
    <IF>
    c = expression() { stmt.cond.add(c); }
    b = block() { stmt.thenBlock.add(b); }
    (
        <ELIF>
        c = expression() { stmt.cond.add(c); }
        b = block() { stmt.thenBlock.add(b); }
    )*
    (
        <ELSE>
        stmt.elseBlock = block()
    )?
    { return stmt; }
}

AstNode statement():
{
    AstNode n;
}
{
    n = expression() <SEMICOLON> { return n; }
|   n = stmtIf() { return n; }
}

AstType baseType():
{
    AstType t = new AstType(), arg;
}
{
    t.name = qualifiedName()
    (
        <LPAREN>
        arg = type() { t.args.add(arg); }
        (
            <COMMA> arg = type() { t.args.add(arg); }
        )*
        <RPAREN>
    |   (
            <LBRACKET>
            <RBRACKET>
            {
                AstType arrayType = new AstType("Array");
                arrayType.args.add(t);
                t = arrayType;
            }
        )+
    )?
    { return t; }
}

AstType type():
{
    AstType t, s, functionType = null;
}
{
    t = baseType()
    (
        <ARROW> s = baseType()
        {
            if (functionType == null) {
                functionType = new AstType("Fn");
                functionType.args.add(t);
                t = functionType;
            }
            functionType.args.add(s);
        }
    )*
    { return t; }
}
