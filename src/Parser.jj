options
{
    // BUILD_TOKEN_MANAGER = false;
    JDK_VERSION = "1.8";
    STATIC = false;
    SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
    // USER_CHAR_STREAM = true;
}

PARSER_BEGIN(Parser)
package owl.lang;

import java.util.ArrayList;
import java.util.List;

public class Parser {
}

PARSER_END(Parser)

SKIP:
{
    " "
  | "\r"
  | "\n"
  | "\t"
  | < "#" (~["\n"])* >
}

TOKEN:
{
    <FN: "fn">
|   <AS: "is">
|   <NEW: "new">
|   <DOT: ".">
|   <COMMA: ",">
|   <COLON: ":">
|   <SEMICOLON: ";">
|   <LPAREN: "(">
|   <RPAREN: ")">
|   <LCURLY: "{">
|   <RCURLY: "}">
|   <LBRACKET: "[">
|   <RBRACKET: "]">
|   <ANN: "@">
|   <TILDE: "~">
|   <NOT: "!">
|   <MUL: "*">
|   <DIV: "/">
|   <MOD: "%">
|   <PLS: "+">
|   <MNS: "-">
|   <SIGNED_RSHIFT: ">>>">
|   <RSHIFT: ">>">
|   <LSHIFT: "<<">
|   <BIT_AND: "&">
|   <BIT_XOR: "^">
|   <BIT_OR: "|">
|   <ARROW: "=>">
|   <OCT: "0o" (["0"-"7"])+>
|   <DEC: (["0"-"9"])+>
|   <HEX: "0x" (["0"-"9", "a"-"f", "A"-"F"])+>
|   <NAME: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

AstModule module():
{
    AstModule m = new AstModule();
    AstFunction f;
}
{
    (
        f = function() { m.addFunction(f); }
    )*
    { return m; }
}

AstName name():
{
    Token tok;
}
{
    tok = <NAME> { return new AstName(tok.image); }
}

AstName qualifiedName():
{
    String name;
    Token tok;
}
{
    tok = <NAME> { name = tok.image; }
    (
        <DOT> tok = <NAME>
        {
            name += "." + tok.image;
        }
    )*
    { return new AstName(name); }
}

AstFunction function():
{
    AstFunction f = new AstFunction();
    AstVariable arg;
}
{
    <FN> f.name = <NAME>.image
    (
        <LPAREN>
        (
            arg = variable() { f.args.add(arg); }
            (
                "," arg = variable() { f.args.add(arg); }
            )*
        )?
        <RPAREN>
    )?
    (
        <COLON> f.returnType = type()
    )?
    f.block = block()
    { return f; }
}

AstVariable variable():
{
    AstVariable v = new AstVariable();
    Token tok;
}
{
    tok = <NAME> { v.name = tok.image; }
    (
        <COLON> v.type = type()
    )?
    { return v; }
}

AstBlock block():
{
    AstBlock b = new AstBlock();
    AstNode s;
}
{
    <LCURLY>
    (
        (
            s = statement() { b.statements.add(s); }
        )?
        <SEMICOLON>
    )*
    <RCURLY>
    { return b; }
}

AstNode prime():
{
    AstNode p = null;
    Token tok;
}
{
    (
        p = name()
    |   tok = <OCT>  { p = new AstConstant(tok.image); }
    |   tok = <DEC>  { p = new AstConstant(tok.image); }
    |   tok = <HEX>  { p = new AstConstant(tok.image); }
    |   <LPAREN> p = expression() <RPAREN>
    )
    { return p; }
}

AstNode call():
{
    AstNode r, arg;
    AstName n;
    AstApply apply;
    Token tok;
}
{
    r = prime()
    (
        (
            // Member lookup.
            <DOT> n = name()
            {
                AstMember m = new AstMember();
                m.left = r;
                m.name = n;
                r = m;
            }

        |   // Regular function call with ().
            {
                apply = new AstApply();
                apply.args.add(r);
                r = apply;
            }
            <LPAREN>
            (
                arg = expression() { apply.args.add(arg); }
                (
                    <COMMA> arg = expression() { apply.args.add(arg); }
                )*
            )?
            <RPAREN>

        |   // Array index [].
            {
                apply = new AstApply();
                apply.args.add(new AstName("[]"));
                apply.args.add(r);
                r = apply;
            }
            <LBRACKET>
            (
                arg = expression() { apply.args.add(arg); }
                (
                    <COMMA> arg = expression() { apply.args.add(arg); }
                )*
            )?
            <RBRACKET>
        )
    )*
    { return r; }
}

AstNode cast():
{
    AstNode r, t;
}
{
    r = call()
    (
        <COLON> t = type()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(":"));
            apply.args.add(r);
            apply.args.add(t);
            r = apply;
        }
    )?
    { return r; }
}

AstNode unary():
{
    Token tok = null;
    AstNode n;
}
{
    (tok = <TILDE> | tok = <NOT> | tok = <PLS> | tok = <MNS>)? n = cast()
    {
        if (tok == null) {
            return n;
        }
        AstApply apply = new AstApply();
        apply.args.add(new AstName(tok.image));
        apply.args.add(n);
        return apply;
    }
}

String multiplicativeOp():
{
    Token tok;
}
{
    tok = <MUL> { return tok.image; }
|   tok = <DIV> { return tok.image; }
|   tok = <MOD> { return tok.image; }
}

AstNode multiplicative():
{
    String op;
    AstNode l, r;
}
{
    l = unary()
    (
        op = multiplicativeOp() r = unary()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

String additiveOp():
{
    Token tok;
}
{
    tok = <PLS> { return tok.image; }
|   tok = <MNS> { return tok.image; }
}

AstNode additive():
{
    String op;
    AstNode l, r;
}
{
    l = multiplicative()
    (
        op = additiveOp() r = multiplicative()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

String shiftOp():
{
    Token tok;
}
{
    tok = <LSHIFT> { return tok.image; }
|   tok = <RSHIFT> { return tok.image; }
|   tok = <SIGNED_RSHIFT> { return tok.image; }
}

AstNode shift():
{
    String op;
    AstNode l, r;
}
{
    l = additive()
    (
        op = shiftOp() r = additive()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(op));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitAnd():
{
    Token tok;
    AstNode l, r;
}
{
    l = shift()
    (
        tok = <BIT_AND> r = shift()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(tok.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitXor():
{
    Token tok;
    AstNode l, r;
}
{
    l = bitAnd()
    (
        tok = <BIT_XOR> r = bitAnd()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(tok.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode bitOr():
{
    Token tok;
    AstNode l, r;
}
{
    l = bitXor()
    (
        tok = <BIT_OR> r = bitXor()
        {
            AstApply apply = new AstApply();
            apply.args.add(new AstName(tok.image));
            apply.args.add(l);
            apply.args.add(r);
            l = apply;
        }
    )*
    { return l; }
}

AstNode expression():
{
    AstNode n;
}
{
    n = bitOr()
    { return n; }
}

AstNode statement():
{
    AstNode expr;
}
{
    expr = expression() { return expr; }
}

AstType baseType():
{
    AstType t = new AstType(), arg;
}
{
    t.name = qualifiedName()
    (
        <LPAREN>
        arg = type() { t.args.add(arg); }
        (
            <COMMA> arg = type() { t.args.add(arg); }
        )*
        <RPAREN>
    |   (
            <LBRACKET>
            <RBRACKET>
            {
                AstType arrayType = new AstType("Array");
                arrayType.args.add(t);
                t = arrayType;
            }
        )+
    )?
    { return t; }
}

AstType type():
{
    AstType t, s, functionType = null;
}
{
    t = baseType()
    (
        <ARROW> s = baseType()
        {
            if (functionType == null) {
                functionType = new AstType("Fn");
                functionType.args.add(t);
                t = functionType;
            }
            functionType.args.add(s);
        }
    )*
    { return t; }
}
